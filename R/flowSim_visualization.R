
#' show_plot
#' 
#' function to visualize the selected plot using the flowSim_plot or flowSim_plot_dens function
#' @param path_data_file Path to the csv files to visualize
#' @param type type of visualization: "classic" or "dens". Default to classic. 
#' the "dens" version has the density of the markers on the side of each axis.
#' @return Plot object
#' @export
#' @examples 
#' \donttest{show_plot(path_data="path to input directory",type="classic")}
show_plot<-function(path_data_file,type="classic"){
  df_plot<-read.csv(path_data_file)
  if(type=="classic"){
    plot_selected<-flowSim_plot(df_plot)
  }else if(type=="dens"){
    plot_selected<-flowSim_plot_dens(df_plot)
  }
  return(plot_selected)
}


#' flowSim_plot
#' 
#' function to generate the scatter plot with colored density of the events. Internal function.
#' @param df Dataframe containing the two markers expression data.
#' @param plot_gate show gates?,default to False
#' @keywords Internal
#' @return Plot object
flowSim_plot<-function(df,plot_gate=F){
  colPalette <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
  col <- densCols(df[,c(1,2)], colramp = colPalette,nbin = 200) # get colors based on bivariate density
  plot<-graphics::plot(df[,c(1,2)],col=col,pch=".",cex=1)
  if(plot_gate==T){
    print("using convex hull as gate")
    list_df_hull<-get_hull_all_gates(df)
    vec<-names(list_df_hull)
    ind<-which(vec=="0")
    if(length(ind)!=0){
      list_df_hull<-list_df_hull[-ind]
    }
    n_hull<-length(list_df_hull)
    for(i in 1:n_hull){
      hull_coords<-list_df_hull[[i]]
      polygon(hull_coords,border="red")
    }
  }
  return(plot)
}

#' flowSim_plot_dens
#' 
#' function to generate the denity scatter plot with density on the sides. Internal function.
#' @param df Dataframe containing the two markers expression data.
#' @keywords Internal
#' @return Plot object
flowSim_plot_dens<-function(df){
  layout(matrix(c(0,1,2,3),byrow = T,nrow = 2),widths = c(2.5,5),heights = c(2.5,5))
  par(mar=rep(0,4))
  # density marker 1
  dens.chan1 <-density(df[,1])
  graphics::plot(dens.chan1, xlim=range(df[,1]), type="l", axes=F, frame.plot=F, ann=F)
  pts <- get_densRange(dens.chan1$x, dens.chan1$y, min(dens.chan1$x,na.rm = T), T)
  polygon(pts$x, pts$y, col="grey", border= "black")
  
  # density marker 2
  dens.chan2 <-density(df[,2])
  graphics::plot(dens.chan2$y, dens.chan2$x, ylim=range(df[,2]), xlim=rev(range(dens.chan2$y)),
                 type="l", col=1,frame.plot=F,axes=F,ann=F)
  pts <- get_densRange(dens.chan2$x, dens.chan2$y,min(dens.chan2$x,na.rm = T) , T)
  polygon(pts$y, pts$x, col="grey", border= "black")
  # bivariate density scatter plot 
  colPalette <- colorRampPalette(c("blue", "turquoise", "green", "yellow", "orange", "red"))
  col <- densCols(df[,c(1,2)], colramp = colPalette,nbin = 200) # get colors based on bivariate density
  plot<-graphics::plot(df[,c(1,2)],col=col,pch=".",cex=1,frame.plot=F,axes=F,ann=F)
  return(plot)
}

#' get_densRange
#' 
#' function to get the correct coordinates (correct range) based on the density 
#' coordinates x and y generated by the density() function. Internal function.
#' @param x x axis density coordinates
#' @param y y axis density coordinates
#' @param thr Treshold of expression where to start the density calculation
#' @param direction On the left (FALSE) or on the right (TRUE) of the threshold
#' @keywords Internal
#' @return Coordinates density points for the x and y axis
get_densRange <- function(x, y, thr, direction = FALSE){
  pts <- list()
  if(is.na(direction))
    return(list(x=c(x,tail(x,1),x[1]), y=c(y,min(y),min(y))))
  if(direction){
    x.pts <- c(x[which(x>=thr)], tail(x[which(x>=thr)],1), x[which(x>=thr)][1])
    y.pts <- c( y[which(x>=thr)], min(y[which(x>=thr)]), min(y[which(x>=thr)]))
  }else{
    x.pts <- c(x[which(x<thr)][1], x[which(x<thr)], thr)
    y.pts <- c(min(y[which(x>=thr)]),y[which(x<thr)], min(y[which(x<thr)]))
  }
  pts$x <- x.pts
  pts$y <- y.pts
  return(pts)
}

# 
#' plot_visnet
#' 
#' function to plot the visnetwork based on the similarity scores
#' @param visnetdata list of dataframes containing the edges and nodes information in VisNetwork format
#' @param show_legend show legend?
#' @param remove_single_files If True, single files (black nodes) are removed from the analysis.
#' @param select_group A vector indicating the names of the groups to visualize. If NULL, 
#' all groups are visualized. Default to NULL
#' @param size_nodes Set size of the nodes. Default to NULL.
#' @return VisNetwork object
#' @export
#' @examples 
#' \donttest{plot_visnet(visnetdata=visnetdata,show_legend=F,remove_single_files=F,select_group=NULL)}
plot_visnet<-function(visnetdata,show_legend=F,remove_single_files=F,select_group=NULL,
                      size_nodes=NULL){
  if(nrow(visnetdata$nodes)>4000){
    stop("too many nodes: plot contracted data")
  }
  # define legend
  lnodes <- data.frame(label = c("Grouped files","Grouped files","Grouped files","Isolated files"), 
                       shape = c("dot"), color = c("red","blue","yellow","black"),
                       title = "Informations")
  
  # check type of visnetwork data (contracted vs uncontracted)
  check_group<-"group" %in% colnames(visnetdata$nodes)
  if(check_group==F){ # because contracted version (id=group),group column is NOT present
    select_by<-"id"
  }else{
    select_by<-"group" # because uncontracted network (id=file name),group column is present
    # do you want remove single files from visualization?
    if(remove_single_files==T){
      inds<-which(visnetdata$nodes$n_files==1)
      visnetdata$nodes<-visnetdata$nodes[-inds,]
    }
    # plot only specific groups from uncontracted network
    if(is.null(select_group)==F){
      check_selected_group<-visnetdata$nodes$group %in% select_group
      inds<-which(check_selected_group==T)
      visnetdata$nodes<-visnetdata$nodes[inds,]
      check_from_id<-visnetdata$edges$from %in% visnetdata$nodes$id
      inds<-which(check_from_id==T)
      visnetdata$edges<-visnetdata$edges[inds,]
      check_to_id<-visnetdata$edges$to %in% visnetdata$nodes$id
      inds<-which(check_to_id==T)
      visnetdata$edges<-visnetdata$edges[inds,]
    }
  }
  # set size nodes
  if(is.null(size_nodes)==F){
    visnetdata$nodes$size<-rep(size_nodes,nrow(visnetdata$nodes))
  }  # generate network object
  visnet<-visNetwork(nodes = visnetdata$nodes, edges = visnetdata$edges,main = "plot clusters network") %>%
    visIgraphLayout(randomSeed = 40,physics = T,layout = "layout_nicely") %>%
    visOptions(highlightNearest = list(enabled =TRUE, degree = 1),selectedBy=list(variable=select_by,main="select by cluster")) %>%
    visInteraction(hideEdgesOnDrag = TRUE) %>%
    visPhysics(stabilization = list(enabled=T,iterations=100,updateInterval=5),timestep = 0.5,minVelocity = 10,maxVelocity = 50) %>%
    visEdges(smooth = FALSE,color="black") %>%
    visLegend(enabled = show_legend,addNodes = lnodes,useGroups = F,width=0.5,ncol=3) %>%
    visEvents(type = "once",stabilizationIterationsDone="function () {this.setOptions( { physics: false } );}") # remove physiscs when stabilization iterations are done
  return(visnet)
}


